/*
Chapter 8: Storing and Processing Text

	Topics Covered:
		- Processing Text with Macro Functions
		- Using SAS Macro Function to Manipulate Character Strings
		- Using SAS Functions with Macro Variables
		- Using SAS Macro Functions to Mask Special Characters
		- Creating Macro Variables during PROC SQL Step Execution
		- Creating Macro Variables during DATA Step Execution
		- Referencing Macro Variables Indirectly
		- Quiz
 */

LIBNAME certadv '/home/u45038867/certadv';

/***************************************
* Processing Text with Macro Variables *
****************************************/

*No Code examples used;



/***********************************************************
* Using SAS Macro Function to Manipulate Character Strings *
************************************************************/

/* The %UPCASE function  */

*defining macro var. Notice lowercase;
%LET paidval=n;
TITLE "Uncollected Fees for Each Course";

PROC MEANS data=certadv.all SUM MAXDEC=0;
	*in Quotes;
	WHERE paid="%upcase(&paidval)";
	VAR fee;
	CLASS course_title;
RUN;



/* The %SUBSTR function */
PROC PRINT data=certadv.schedule;
	WHERE begin_date BETWEEN "30%SUBSTR(&SYSDATE9, 3)"d and "&SYSDATE9"d;
	TITLE "All Courses Held So Far This Month";
	TITLE2 "(as of &sysdate9)";
RUN;


/* The %INDEX Function */
%LET a = a very long value;
%LET b=%INDEX(&a, v);*returns the position of the first occurance of v;

%PUT The Character v appears at position &b;

/* The %SCAN Function */
%LET a=one:two-three four;

%PUT First word is %scan(&a, 1);*uses default delims, 3 words total;
%PUT Second word is %scan(&a, 2, :-);*uses : and - as delimiters;
%PUT Last word is %scan(&a, -1);*returns the last word;



/*******************************************
* Using SAS Functions with Macro Variables *
********************************************/

/* The %sysfunc Function  */
%LET string = william SMITH;
%PUT %sysfunc(propcase(&string));


/* The %EVAL Function */
%LET a=1+2;
%LET b=10*3;
%LET c=13/3;

%LET eval_a=%eval(&a);
%LET eval_b=%eval(&b);
%LET eval_c=%eval(&c);

%PUT &a is &eval_a;
%PUT &b is &eval_b;
%PUT &c is &eval_c;*Only the integer portion is returned;


/* The %SYSEVALF Function */

%macro figureit(a, b);
	%LET y=%sysevalf(&a+&b);
	%PUT The result with SYSEVAL is: &y;
	%PUT The BOOLEAN value is: %sysevalf(&a +&b, boolean);
	%PUT The CEIL value is: %sysevalf(&a +&b, ceil);
	%PUT The FLOOR value is: %sysevalf(&a +&b, floor);
	%PUT The INTEGER value is: %sysevalf(&a +&b, int);
%mend figureit;

%figureit(100, 1.597);

/********************************************************
*  Using SAS Macro Functions to Mask Special Characters *
*********************************************************/

*The %STR function;
OPTIONS symbolgen;
*Since this a paired token, need to precede token 
with a % within %STR;
%let text=%STR(Joan%'s Report);

PROC PRINT data=certadv.courses;
	WHERE days > 3;
	TITLE "&text";
RUN;


*Using the %NRSTR function;
%LET period = %STR(May&June);
%PUT Period resolves to &period;

%LET period =%NRSTR(May&Jun);
%PUT Period resolves to &period;


*Using the %SUPERQ Function;
data _null_;
	call symputx('mv1', 'Smith&Jones');
	call symputx('mv2', '%macro abc;');
RUN;

%LET testmv1=%superq(mv1);
%LET testmv2=%superq(mv2);
%PUT Macro variable TESTMV1 is &testmv1;
%PUT Macro variable TESTMV@ is &testmv2;


*Using the %BQUOTE Function;
data _null_;
	call symputx('text', "Sally's Seashell Store at Old Towne's Beach");
RUN;

data _null_;
	PUT "%bquote(&text)";
RUN;


*Using the %QUPCASE Function;
%LET a=%NRSTR(Address&Name);
%PUT QUPCASE produces: %QUPCASE(&a);


*Using the %QSUBSTR function;
%LET a=one;
%LET b=two;
%LET c=%NRSTR(&a &b);

%PUT C: &c;
%PUT With SUBSTR: %SUBSTR(&c, 1, 2);
%PUT With QSUBSTR: %QSUBSTR(&c, 1, 2);


*Using the %QSCAN Function;
%macro a;
	aaaaaa
%mend a;

%macro b;
	bbbbbb
%mend b;

%macro c;
	cccccc
%mend c;

%LET x=%NRSTR(%a*%b*%c);
%PUT X: &x;
%PUT The third word in X, with SCAN: %scan(&x,3,*);
%PUT The third word in X, with QSCAN: %qscan(&x,3,*);


*Using the %QSYSFUNC Function;
TITLE "Report Produced on %SYSFUNC(left(%QSYSFUNC(today(), worddate.)))";

PROC PRINT data=sashelp.cars;
RUN;


/**********************************************************
* Creating Macro Variables during PROC SQL Step Execution *
***********************************************************/
*Example with INTO and NOPRINT statements;
PROC SQL NOPRINT;
	SELECT SUM(fee) format=dollar10.
		INTO :totalfee trimmed
		FROM certadv.all;
QUIT;

PROC MEANS data=certadv.all SUM MAXDEC=0;
	CLASS course_title;
	var fee;
	TITLE "Grand Total for All Courses Is &totalfee";
RUN;


*Example: Creating Variables with the INTO Clause;
PROC SQL NOPRINT;
	SELECT course_code, location, begin_date format=mmddyy10.
		INTO :crsid1-, 
			 :place1-,
			 :date1-
		FROM certadv.schedule
		WHERE YEAR(begin_date)=2019
		ORDER BY begin_date;
QUIT;

*Displaying the number of rows from SQL Query;
%PUT There are &SQLOBS courses in 2019;

*Displaying the names of all user created macro variables;
%PUT _user_;


*Creating a Delimited List of Values;
PROC SQL NOPRINT;
	SELECT DISTINCT location
		INTO :sites separated by ', ' /* creates a list of values */
		FROM certadv.schedule;
QUIT;

TITLE1 'Total Revenue from Course Sites:';
TITLE2 Course sites are: &sites;
PROC MEANS data=certadv.all SUM maxdec=0;
	VAR fee;
RUN;



/******************************************************
* Creating Macro Variables during DATA Step Execution *
*******************************************************/
*Using the CALL SYMPUTX Routine;
%LET crsnum=3;

DATA revenue;
	SET certadv.all end=final;
	where course_number=&crsnum;
	
	*Counting total number of students;
	total+1;
	
	*Counting number of students who have paid fee;
	IF paid='Y' then paidup+1;
	
	IF final then do;
		*Creating mcro vars if end of dataset;
		CALL SYMPUTX('crsname', course_title);
		CALL SYMPUTX('date', put(begin_date, mmddyy10.));
		CALL symputx('due', put(fee*(total-paidup), dollar8.));
	END;
RUN;

PROC PRINT data=revenue;
	VAR student_name student_company paid;
	TITLE "Fee Status for &crsname (#&crsnum) Held &date";
	FOOTNOTE "Note: &due in Unpaid Fees";
RUN;


*Using CALL SYMPUTX Routine with Literal Strings;
OPTIONS SYMBOLGEN PAGESIZE=30;

%LET crsnum=3;

DATA revenue;
	SET certadv.all end=final;
	WHERE course_number=&crsnum;
	total+1;
	
	IF paid='Y' then paidup+1;
	IF final then DO;
		IF paidup<total then DO;
			CALL SYMPUTX('foot', 'Some Fees are Unpaid');
		END;
		ELSE DO;
			CALL SYMPUTX('foot', 'All students have paid');
		END;
	END;
RUN;


PROC PRINT data=work.revenue;
	VAR student_name student_company paid;
	TITLE "Payment Status for Course &crsnum";
	FOOTNOTE "&foot";
RUN;


*Example: Using the CALL SYMPUTX Routine with a DATA Step Variable;
%LET crsnum=3;
DATA revenue;
	SET certadv.all end=final;
	WHERE course_number=&crsnum;
	total+1;
	
	IF paid='Y' THEN paidup+1;
	
	IF final THEN DO;
		CALL SYMPUTX('numpaid', paidup);
		CALL SYMPUTX('numstu', total);
		CALL SYMPUTX('crsname', course_title);
		CALL SYMPUTX('percpaid', put(paidup/total, percent5.2));
	END;
RUN;

PROC PRINT data=revenue noobs;
	VAR student_name student_company paid;
	TITLE "Fee Status for &crsname (#crsnum)";
	FOOTNOTE "Note: &numpaid Paid out of &numstu (&percpaid)";
RUN;


*Creating Multiple Macro Variables with CALL SYMPUTX;
DATA _null_;
	SET certadv.courses;
	*both arguments are column names in the courses dataset;
	*They values change for each iteration of the DATA step;
	CALL symputx(course_code, course_title);
RUN;

%PUT _user_;


*Using the PUT Function;
%LET crsnum=3;

DATA revenue;
	SET certadv.all end=final;
	where course_number=&crsnum;
	
	*Counting total number of students;
	total+1;
	
	*Counting number of students who have paid fee;
	IF paid='Y' then paidup+1;
	
	IF final then do;
		*Creating mcro vars if end of dataset;
		CALL SYMPUTX('crsname', course_title);
		CALL SYMPUTX('date', put(begin_date, mmddyy10.));
		CALL symputx('due', put(fee*(total-paidup), dollar8.));
	END;
RUN;

PROC PRINT data=revenue;
	VAR student_name student_company paid;
	TITLE "Fee Status for &crsname (#&crsnum) Held &date";
	FOOTNOTE "Note: &due in Unpaid Fees";
RUN;




/*****************************************
* Referencing Macro Variables Indirectly *
******************************************/
DATA _null_;
	SET certadv.courses;
	CALL SYMPUTX(course_code, course_title);
RUN;

%LET crsid=C002;

PROC PRINT data=certadv.schedule noobs label;
	WHERE course_code="&crsid";
	VAR location begin_date teacher;
	TITLE1 "Schedule for &&&crsid";



*Creating a Series of Macro Variables;
OPTIONS SYMBOLGEN;
DATA _null_;
	SET certadv.schedule;
	call SYMPUTX(CATS('teach', course_number), teacher);
RUN;


%LET crs=3;
PROC PRINT data=certadv.register noobs;
	WHERE course_number=&crs;
	VAR student_name paid;
	TITLE1 "Roster for Course &crs";
	TITLE2 "Taught by &&teach&crs";
RUN;
